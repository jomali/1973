

!!------------------------------------------------------------------------------
!! Representa un objeto al que el jugador puede entrar o subirse encima.
!!------------------------------------------------------------------------------
Class	SmartEnterable
 with	react_before [; if (parent(player) ~= self) return false;
			!! GROUP 2 ACTIONS: Usually work, given the right circumstances.
			Close, Open:
				if (noun hasnt openable)						return false;
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			Disrobe, Wear:
				if (noun == nothing or player or self)			return false;
				if (noun hasnt clothing)						return false;
				<Exit self>; new_line;
				return false;
			Drop: !! TODO: Comprobar funcionamiento
				return false;
			Eat:
				if (noun hasnt edible)							return false;
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			Empty, Remove, Search, Take:
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			EmptyT: !! TODO: Comprobar funcionamiento
				if (ObjectIsUntouchable(noun, 1)) return false;
				if (self.out_of_reach(second)) { <Exit self>; new_line; }
				return false;
			! Enter:
			Exit:
				if (noun == nothing) <<Exit self>>;
			! GetOff:
			! Give:
			Go:
				if (noun == nothing or player or self)			return false;
				if (~~(noun ofclass CompassDirection))			return false;
				<Exit self>; new_line;
				return false;
			! GoIn:
			Insert, PutOn:
				if ((second == d_obj) || (player in second)) <<Drop noun>>;
				if (self.out_of_reach(second)) { <Exit self>; new_line; }
				return false;
			Lock, Unlock:
				if (noun hasnt lockable)						return false;
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			! Order:
			! Show:
			SwitchOff, SwitchOn:
				if (noun hasnt switchable)						return false;
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			Transfer: !! TODO: Comprobar funcionamiento
				if (noun notin player)							return false;
				return false;
			!! GROUP 3 ACTIONS: Output a message and stop at the "before" stage.
			! Answer:
			! Ask:
			! AskFor:
			Attack, Blow, LookUnder, Smell, Squeeze, Taste, Touch:
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			Burn:
				!! TODO: comprobaciones de noun y second
				return false;
			! Buy:
			Climb:
				if (noun has enterable) {
					if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				}
				return false;
			! Consult:
			! Fill:
			Jump:
				if (noun == nothing) <<Exit self>>;
			! JumpOver:
			! Kiss:
			! LetGo:
			! Listen:
			! Mild:
			! No:
			! Pray:
			Pull, Push, Turn: !! TODO: Comprobar funcionamiento
				! if (noun has scenery or static or concealed)	return false;
				if (self.out_of_reach(noun)) { <Exit self>; new_line; }
				return false;
			! PushDir
			! Receive
			! Rub
			! Set
			! SetTo
			! Swim
			Swing:
				if (noun == nothing) <<Swing self>>;
			! Tell
			! Wake
			! WakeOther
			! Wave
			! WaveHands
			!! CUSTOM ACTIONS
			! Dance:
			! GoDown:
			! GoUp:
			! KnockOn:
			! Masturbate:
			! Sit:
			! SleepWith:
			StandUp:
				if (noun == nothing) <<Exit self>>;
			! TalkTo:
			! Untie:
			! Use:
		],
		reach_zones 0,
 private
		!! Dado un objeto como parámetro, retorna su antecesor más lejano 
		!! previo a los objetos localidad. (En el árbol de objetos del modelo 
		!! de mundo, los objetos localidad ocuparían el nivel 1 del árbol 
		!! mientras que el resultado de la rutina ocuparía el nivel 2).
		top_holder [ obj i;
			!print "** top_holder de ", (name) obj, ": ";
			while (parent(obj) ~= 0) {
				i = ObjectScopedBySomething(obj);
				if (i == 0) i = parent(obj);
				if (parent(i) == 0) break;
				obj = i;
			}
			!print (name) obj, ".^";
			return obj;
		],
		!! Indica si el objeto pasado como parámetro se encuentra fuera de 
		!! alcance desde el SmartEnterable. Retorna verdadero si el objeto está 
		!! fuera de alcance, falso en caso contrario. [Código adaptado de la 
		!! librería OutOfRch.h v2.00, de Marnie Parker <doeadeer3@aol.com>].
		out_of_reach [ obj 		top x y i;
			!! Se comprueba si el objeto se encuentra fuera de la localidad o 
			!! en el interior de un contenedor cerrado:
			if (ObjectIsUntouchable(obj, true)) return false;
			!! Se comrpueba si el objeto se encuentra en el jugador o en el 
			!! propio SmartEnterable:
			if (IndirectlyContains(player, obj)) return false;
			if (IndirectlyContains(self, obj)) return false;
			!! Se comprueba si el objeto es o se encuentra contenido en alguna 
			!! de las reach_zones:
			top = self.top_holder(obj);
			if (ZRegion(self.&reach_zones-->0) == 1 or 2) {
				if (ZRegion(self.&reach_zones-->0) == 2) {
					x = self.reach_zones();
					if (x == top) return false;
				} else {
					y = self.#reach_zones;
					for (i = 0 : i < (y/2) : i++) {
						x = self.&reach_zones-->i;
						if (x == top) return false;
					}
				}
			}
			!! El objeto se encuentra fuera del alcance:
			return true;
		],
 has	enterable;
