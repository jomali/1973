!% -SD
!% +language_name=Spanish
!% $MAX_LABELS=2000
!% $MAX_ZCODE_SIZE=45000
!% $list


!!==============================================================================
!!
!!	PROYECTO 1973
!!
!!==============================================================================
!!
!!	File:			1973.inf
!!	Author(s):		J. Francisco Martín (jfm.lisaso@gmail.com)
!!	Languague:		ES (Castellano)
!!	System:			Inform, INFSP 6
!!	Platform:		Z-Machine / GLULX
!!	Version:		0.1
!!	Released:		2014/01/27
!!
!!------------------------------------------------------------------------------
!!
!!	Copyright (c) 2014, J. Francisco Martín
!!
!!	This file is part of PROYECTO 1973.
!!
!!	PROYECTO 1973 is free software: you can redistribute it and/or modify 
!!	it under the terms of the GNU General Public License as published by 
!!	the Free Software Foundation, either version 3 of the License, or 
!!	(at your option) any later version.
!!
!!	PROYECTO 1973 is distributed in the hope that it will be useful, 
!!	but WITHOUT ANY WARRANTY; without even the implied warranty of 
!!	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the 
!!	GNU General Public License for more details.
!!
!!	You should have received a copy of the GNU General Public License 
!!	along with PROYECTO 1973. If not, see <http://www.gnu.org/licenses/>.
!!
!!------------------------------------------------------------------------------


!!==============================================================================
!!	Constantes y variables globales del relato
!!------------------------------------------------------------------------------

Constant Story "PROYECTO 1973";
Constant Headline "Un relato interactivo de J. Francisco Martín, 2014";

!Constant ALPHA_RELEASE;		! Fase de desarrollo ALFA
!Constant TEST_SCENE1;			! Escena en pruebas
!Constant Checking 1;			! Código de la versión del relato
!Release 0; Serial "130918";

Constant DEMO_RELEASE;			! Versión de demostración
Constant Checking 1;			! Código de la versión del relato
Release 0; Serial "140120";		! 1.0 - 2014/01/20

Constant MANUAL_PRONOUNS;		! Los pronoms. refieren a objetos ya mencionados
Constant NO_PLACES;				! Acciones LUGARES Y OBJETOS desactivadas
Constant NO_SCORE;				! No se lleva conteo de puntuación
Constant SIN_MENSAJES;			! Se omiten los mensajes por defecto de la lib.
Constant MAX_CARRIED = 3;		! Máx. de objetos que se pueden llevar en mano
Constant SACK_OBJECT = ropa;	! Contenedor principal para la librería

Constant PARSER_STYLE _IST_;	! Selecciona estilo de los mensajes del parser
Constant PARSER_PREFIX "[";		! Define texto inicial de mensajes del parser
Constant PARSER_SUFIX "]";		! Define texto final de mensajes del parser

Global flowers;					! Tipo de flor destacado en el relato (NOTA #1)
Global say_switch = true;		! Interruptor de la función say()
Global next_track;				! Siguiente pista de audio a reproducir


!!==============================================================================
!!	Reemplazos de rutinas utilizadas por la librería Inform
!!------------------------------------------------------------------------------

Replace AttemptToTakeObject;	! Intento de transferir un objeto al jugador
Replace Banner;					! Créditos generales de la aplicación
Replace DisrobeSub;				! Rutina para la acción #Disrobe
Replace DrawStatusLine;			! Dibuja la barra de estado
Replace GetGNAOfObject;			! Rutina para obtener el GNA de un objeto
Replace InvSub;					! Rutinas para tomar INVENTARIO del personaje
Replace InvTallSub;				! Rutinas para tomar INVENTARIO del personaje
Replace InvWideSub;				! Rutinas para tomar INVENTARIO del personaje
Replace LMode1Sub;				! Lookmode 1: Breve
Replace LMode2Sub;				! Lookmode 2: Largo (establecido por defecto)
Replace LMode3Sub;				! Lookmode 3: Superbreve
Replace LookSub;				! Rutina para la acción #Look
Replace VersionSub;				! Créditos detallados de la aplicación
Replace WearSub;				! Rutina para la acción #Wear


!!==============================================================================
!!	Librerías y extensiones (Parte 1 de 2)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
Include "gwindefs.h";			! GWindows: Definiciones
#Endif; ! TARGET_GLULX;

Include "Parser.h";				! Decodifica la entrada del teclado
Include ">1973_lib.inf";		! Personalizaciones de la librería Inform
Include ">1973_langLM.inf";		! Mensajes de la librería

#Ifdef TARGET_GLULX;
Include "gwincls.h";			! GWindows; Window Class Framework
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	Puntos de entrada para Glk (sólo en Glulx)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
!!------------------------------------------------------------------------------
!!	Rutina gancho encargada de reinicializar Damusix y recuperar los canales de 
!!	audio. (Sin esta rutina, al reiniciar la aplicación la música se solapará 
!!	con aquella que se estuviese reproduciendo durante la partida anterior).
!!------------------------------------------------------------------------------
[ GWindowsGlkIdentify phase type ref rock;
	!! Se identifican todos los Objetos de Sonido gestionados por Damusix
	Damusix.IdentificarSonidos(phase);
	phase = type + ref + rock; ! (para evitar alertas del compilador)
];

!!------------------------------------------------------------------------------
!! Controlador de eventos Glk con la librería GWindows.
!!------------------------------------------------------------------------------
[ GWindowsGlkEvent ev context abortres;
	!! Se notifica el efecto de fade de Tiempo Real
	Damusix.NotificarFade(ev);
	!! Se gestiona el evento glk:
	switch (ev-->0) {
	0:	! evtype_None        - none
	1:	! evtype_Timer       - event repeated at fixed intervals
		AimingManager.run();
	2:	! evtype_CharInput   - keystroke input in a window
	3:	! evtype_LineInput   - full line of input in a window
	4:	! evtype_MouseInput  - mouse input in a window
	5:	! evtype_Arrange     - some windows sizes have changed
	6:	! evtype_Redraw      - graphic windows need redrawing
	7:	! evtype_SoundNotify - sound finished playing
		if (next_track ~= 0) {
			Damusix.Tocar(next_track, 1);
			next_track = 0;
		}
	8:	! evtype_Hyperlink   - selection of a hyperlink in a window
	}
	ev = context + abortres; ! (para evitar alertas del compilador)
];
#Endif; ! TARGET_GLULX;


!!==============================================================================
!!	Librerías y extensiones (Parte 2 de 2)
!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
Include "damusix.h";			! Administrador unificado de sonido en Glulx
Include "gwindows.h";			! GWindows: Remplazos de la librería
Include ">1973.bli";			! Recursos multimedia de la aplicación
Include ">1973_gui.inf";		! Definición de la interfaz gráfica
#Endif; ! TARGET_GLULX;

Include "aimAndFire.h";			! Sistema de apuntado y disparo QTE
Include "receptacles.h";		! Contenedores (con capacidad limitada)
Include "topicInventory.h";		! Sistema de conversación con inv. de temas
Include "types.h";				! Rutinas para modificar estilo de los textos

Include "VerbLib.h";			! Define cómo trabajan las acciones


!!==============================================================================
!!	Puntos de entrada y otras rutinas
!!------------------------------------------------------------------------------

!!------------------------------------------------------------------------------
!! Inicialización del relato.
!!------------------------------------------------------------------------------
[ Initialise;
	EraseWindow();				! Borra la ventana
	flowers = GetFlowerType();	! Tipo de flor destacado a lo largo de relato
	lookmode = 2;				! Modo de las descripciones de localidad autom.

	!! Comprobaciones multimedia:
	#Ifdef TARGET_GLULX;
	HideGraphicWindow();
	if (~~Damusix.TestAudio()) {
		print (strong) "AVISO:", " Esta aplicación incluye contenidos gráficos 
		y de audio, pero tu intérprete GLULX no los soporta adecuadamente. El 
		programa se iniciará con parte o la totalidad de sus recursos 
		multimedia desactivados.^";
		new_line;
		print (parser) "Pulsa una tecla para continuar";
		PressAnyKey();
		EraseWindow();
	}
	#Endif; ! TARGET_GLULX;

	!! Advertencia de la demostración:
	#Ifdef DEBUG;
	#Ifdef DEMO_RELEASE;
	print (strong) "AVISO:", " Esta aplicación es una versión de demostración 
	de un relato interactivo pendiente de publicar. Los contenidos (en especial 
	los textos) mostrados a continuación pueden no ajustarse necesariamente a 
	los de la versión final.^";
	new_line;
	print (parser) "Pulsa una tecla para continuar";
	PressAnyKey();
	EraseWindow();
	#Endif; ! DEMO_RELEASE;
	#Endif; ! DEBUG;

	location = MainMenu();		! Menú principal. Establece la localidad inicial

	return 2;
];

!!------------------------------------------------------------------------------
!!	Menú principal.
!!------------------------------------------------------------------------------
[ MainMenu i key initialLocation;
	EraseWindow();
	Banner();
	new_line;
	HorizontalRule();
	new_line;
	monospaced_style();
	print "  Empezar la demostración  ";
		for (i=0 : i<(ScreenWidth() - 1 - 40) : i++) print ".";
		print "  [ESPACIO]  ^";
	print "  Ir al índice de escenas  ";
		for (i=0 : i<(ScreenWidth() - 1 - 40) : i++) print ".";
		print "      I      ^";
	print "  Recuperar partida guardada  ";
		for (i=0 : i<(ScreenWidth() - 1 - 43) : i++) print ".";
		print "      R      ^";
	print "  Salir de la aplicación  ";
		for (i=0 : i<(ScreenWidth() - 1 - 39) : i++) print ".";
		print "      Q      ^";
	roman_style();

	key = KeyCharPrimitive();
	switch (key) {
		'I', 'i': initialLocation = IndexMenu();
		'R', 'r': EraseWindow(); print "Cargando partida...^"; <<Restore>>;
		'Q', 'q': quit;
		default: initialLocation = cama;
	}

	EraseWindow();
	return initialLocation;
];

!!------------------------------------------------------------------------------
!!	Menú con el índice de escenas.
!!	TODO - Activar escenas no disponibles
!!------------------------------------------------------------------------------
[ IndexMenu i key initialLocation; 
	EraseWindow();
	monospaced_style();
	print "  ÍNDICE  ^";
	new_line;
	print "  Escena 1: Habitación de Gabriel  ";
		for (i=0 : i<(ScreenWidth() - 1 - 48) : i++) print ".";
		print "      1      ^";
	print "  Escena 2: Café Blanca Florida (no disponible)  ";
		for (i=0 : i<(ScreenWidth() - 1 - 62) : i++) print ".";
		print "      -      ^";
	print "  Escena 3: Calles de Santiago  ";
		for (i=0 : i<(ScreenWidth() - 1 - 45) : i++) print ".";
		print "      3      ^";
	print "  Escena 4: San Antonio (no disponible)  ";
		for (i=0 : i<(ScreenWidth() - 1 - 54) : i++) print ".";
		print "      -      ^";
	new_line;
	print "  Volver al menú principal  ";
		for (i=0 : i<(ScreenWidth() - 1 - 41) : i++) print ".";
		print "      I      ^";
	roman_style();

	key = KeyCharPrimitive();
	switch (key) {
		'1': initialLocation = cama;
!		'2': initialLocation = CAFE;
		'3': initialLocation = TAXI;
!		'4': initialLocation = SAN_ANTONIO;
		default: return MainMenu();
	}

	EraseWindow();
	return initialLocation;
];

!!------------------------------------------------------------------------------
!!	Manipula la entrada del usuario antes de que sea analizada por la librería.
!!------------------------------------------------------------------------------
[ BeforeParsing; 
	ConversationManager.try();
];

!!------------------------------------------------------------------------------
!!	Foco del jugador.
!!------------------------------------------------------------------------------
[ InScope person item;
	!! En la oscuridad, se mueven al foco del jugador todos aquellos objetos 
	!! que hayan sido ya manipulados previamente por el personaje
	if ( person == player && location == thedark ) {
		objectloop(item in parent(player))
			if (item has moved) PlaceInScope(item);
	}
	return false;
];

!!------------------------------------------------------------------------------
!!	Deja la ventana en blanco.
!!------------------------------------------------------------------------------
[ EraseWindow;
    #Ifdef TARGET_ZCODE;
    @erase_window -1;
    #Ifnot; ! TARGET_GLULX
    if (gg_quotewin) {
		glk($0024, gg_quotewin, 0); ! close_window
		gg_quotewin = 0;
    }
    glk($002A, gg_mainwin); ! window_clear
    if (gg_statuswin) glk($002A, gg_statuswin); ! window_clear
    #Endif;
];

!!------------------------------------------------------------------------------
!!	Espera una pulsación de tecla o, si se introduce un valor, a que pase una 
!!	cantidad delay de décimas de segundo antes de continuar. Retorna verdadero 
!!	si la tecla pulsada es 'q' o 'Q', falso en caso contrario.
!!------------------------------------------------------------------------------
[ PressAnyKey delay char;
	#Ifdef TARGET_GLULX;
	if (Damusix.EnFade()) delay = 0;
	#Endif; ! TARGET_GLULX;
	if (delay > 0) char = KeyDelay(delay);
	else char = KeyCharPrimitive();
	if (char == 'q' or 'Q') return true;
	else return false;
];

!!------------------------------------------------------------------------------
!!	Imprime una regla horizontal centrada en pantalla.
!!------------------------------------------------------------------------------
[ HorizontalRule;
	monospaced_style();
	spaces (ScreenWidth()-1-7) / 2;
	print "*  *  *^";
	roman_style();
];

!!------------------------------------------------------------------------------
!!	Imprime un mensaje text y, si el interruptor "say_switch" está activado, 
!!	espera una pulsación de tecla para continuar.
!!------------------------------------------------------------------------------
[ Say text;
	if (text ofclass String && text ~= 0) print (string) text;
	if (say_switch) say_switch = PressAnyKey();
	new_line;
];

!!------------------------------------------------------------------------------
!!	Cada vez que se inicia el relato se selecciona de manera aleatoria un tipo 
!!	de flor de entre el siguiente conjunto de valores posibles {crisantemos, 
!!	gladiolos, jazmines, madreselvas, narcisos, rosas, tulipanes, violetas}. La 
!!	variable global "flowers" (NOTA #1) guardará el tipo de flor seleccionado.
!!------------------------------------------------------------------------------
[ GetFlowerType;
	switch (random(8)) {
		1:	return crisantemos;
		2:	return gladiolos;
		3:	return jazmines;
		4:	return madreselvas;
		5:	return narcisos;
		6:	return rosas;
		7:	return tulipanes;
		8:	return violetas;
	}
];

Object	crisantemos "crisantemos"
 with	name_mp	'crisantemos', 
		gender	G_MASCULINO + G_PLURAL, 
 has	male pluralname scenery;

Object	gladiolos "gladiolos"
 with	name_mp	'gladiolos', 
		gender	G_MASCULINO + G_PLURAL, 
 has	male pluralname scenery;

Object	jazmines "jazmines"
 with	name_mp	'jazmines', 
		gender G_MASCULINO + G_PLURAL, 
 has	male pluralname scenery;

Object	madreselvas "madreselvas"
 with	name_fp	'madreselvas', 
		gender G_FEMENINO + G_PLURAL, 
 has	female pluralname scenery;

Object	narcisos "narcisos"
 with	name_mp	'narcisos', 
		gender	G_MASCULINO + G_PLURAL, 
 has	male pluralname scenery;

Object	rosas "rosas"
 with	name_fp	'rosas', 
		gender	G_FEMENINO + G_PLURAL, 
 has	female pluralname scenery;

Object	tulipanes "tulipanes"
 with	name_mp	'tulipanes', 
		gender	G_MASCULINO + G_PLURAL, 
 has	male pluralname scenery;

Object	violetas "violetas"
 with	name_fp	'violetas', 
		gender	G_FEMENINO + G_PLURAL, 
 has	female pluralname scenery;

!!------------------------------------------------------------------------------
!!	Rutinas y definiciones requeridas para lanzar la acción ##Examine sobre un 
!!	objeto tecleando únicamente su nombre. Sigue la implementación propuesta en 
!!	<http://rec.arts.int-fiction.narkive.com/Cz9j184N/inform-6-parser-question> 
!!	con modificaciones para que sólo se intente lanzar la acción sobre objetos 
!!	que realmente existen y están presentes dentro del foco del jugador. De 
!!	otra forma, siempre se intentaría lanzar la acción ##Examine, aún cuando la 
!!	intención del jugador no fuese examinar un objeto si no utilizar una acción 
!!	que no está definida.
!!------------------------------------------------------------------------------
[ UnknownVerb word obj;
	objectloop(obj) {
		if (TestScope(obj, player)) {
			if ((WordInProperty(word, obj, name)) 
				|| (WordInProperty(word, obj, name_m))
				|| (WordInProperty(word, obj, name_f))
				|| (WordInProperty(word, obj, name_mp))
				|| (WordInProperty(word, obj, name_fp))) {
				verb_wordnum = 0;
				return 'no.verb';
			}
		}
	}
	return false;
];

[ PrintVerb word;
	if (word == 'no.verb') {
		print "hacer algo con";
		return true;
	}
	return false;
];

Verb 'no.verb' * noun -> Examine;

!!------------------------------------------------------------------------------
!!	Rutinas utilizadas por la acción ##RemarkableObjects para imprimir listado 
!!	de objetos destacados del foco del jugador.
!!------------------------------------------------------------------------------
Global remarkableObjectsCount;
[ CountRemarkableObjects obj; 
	if (obj has remarkable) remarkableObjectsCount++;
];
[ PrintRemarkableObjects obj;
	if (obj has remarkable) {
		PronounNotice(obj);
		print " ", (the) obj;
		remarkableObjectsCount--;
		if (remarkableObjectsCount > 1) print ",";
		else if (remarkableObjectsCount == 1) print " y";
	}
];

!!------------------------------------------------------------------------------
!!	Comprueba que se cumplan las condiciones bajo las que se puede hacer un 
!!	disparo con el revólver. Retorna verdadero si se el revólver está en 
!!	condiciones de disparar, o falso en caso contrario.
!!------------------------------------------------------------------------------
[ CheckFireAtConditions obj;
	!! El único objeto con el que se puede disparar es el revólver:
	if (obj ~= nothing or revolver) {
		switch (GRAMMATICAL_INFLECTION) {
			1:	"Necesito un arma para hacer algo así.^";
			2:	"Necesitas un arma para hacer algo así.^";
			3:	"Necesita un arma para hacer algo así.^";
			4:	"Necesitaba un arma para hacer algo así.^";
			5:	"Necesitabas un arma para hacer algo así.^";
			6:	"Necesitaba un arma para hacer algo así.^";
		}
		return false;
	}
	!! Gabriel tiene que tener el revolver en las manos para hacer el disparo:
	if (obj == nothing && revolver notin player) {
		switch (GRAMMATICAL_INFLECTION) {
			1:	print "Primero trato de coger ", (the) revolver, ":^";
			2:	print "Primero tratas de coger ", (the) revolver, ":^";
			3:	print "Primero trata de coger ", (the) revolver, ":^";
			4:	print "Primero traté de coger ", (the) revolver, ":^";
			5:	print "Primero trataste de coger ", (the) revolver, ":^";
			6:	print "Primero trató de coger ", (the) revolver, ":^";
		}
		<Take revolver>;
		if (revolver notin player) return false;
		else new_line;
	}
	!! El revólver tiene que tener balas:
	if (revolver.out_of_ammo()) {
		switch (GRAMMATICAL_INFLECTION) {
		1:	print (The) revolver, " está", (n) revolver, " descargad", 
			(o) revolver, ". No puedo disparar.^";
		2:	print (The) revolver, " está", (n) revolver, " descargad", 
			(o) revolver, ". No puedes disparar.^";
		3:	print (The) revolver, " está", (n) revolver, " descargad", 
			(o) revolver, ". No puede disparar.^";
		4:	print (The) revolver, " estaba", (n) revolver, " descargad",
			(o) revolver, ". No podía disparar.^";
		5:	print (The) revolver, " estaba", (n) revolver, " descargad",
			(o) revolver, ". No podías disparar.^";
		6:	print (The) revolver, " estaba", (n) revolver, " descargad",
			(o) revolver, ". No podía disparar.^";
		}
		return false;
	}
	!! Se cumplen todas las condiciones. Retorna verdadero:
	return true;
];


!!==============================================================================
!!	Gramática estándar y extendida
!!------------------------------------------------------------------------------

Include	"SpanishG.h";		! Gramática española
Include	"SpanishEG.h";		! Gramática española extendida

!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
Verb meta 'audio' 'music' 'musica' 'sonido' 'sonidos'
	*								-> Audio
	* 'on' / 'si'					-> AudioOn
	* 'encendido' / 'activado'		-> AudioOn
	* 'off' / 'no'					-> AudioOff
	* 'apagado' / 'desactivado'		-> AudioOff
;
VerboIrregular "establecer la reproducción de audio"
	with imperativo 'audio' 'music' 'musica' 'sonido' 'sonidos';
#Endif; ! TARGET_GLULX;

Extend	'corre' replace
	* noun							-> CloseX
;

Verb	'desnuda' 'desviste'
	*								-> Disrobe
	* '-te'/'-me'					-> Disrobe
	* noun							-> Disrobe
	* '-te'/'-me' noun				-> Disrobe
;
VerboIrregular "desvestir" with imperativo 'desnuda' 'desviste';

Verb	'apunta' 'dispara' 'tirotea'
	*								-> FireAt
	* noun							-> FireAt
	* 'a//'/'hacia' noun			-> FireAt
	* 'a//'/'hacia' noun 'con' held	-> FireAt
	* noun 'con' held				-> FireAt
	* held 'a//'/'hacia' noun		-> FireAt reverse
	* 'con' held 'a//'/'hacia' noun	-> FireAt reverse
;

Verb meta 'ayuda' 'ayudas' 'pista' 'pistas' 'sos' 'tutorial'
	*								-> HelpOn
	* 'on' / 'si'					-> HelpOn
	* 'encendido' / 'activado'		-> HelpOn
	* 'off' / 'no'					-> HelpOff
	* 'apagado' / 'desactivado'		-> HelpOff
;
VerboIrregular "mostrar ayuda" with imperativo 
	'ayuda' 'ayudas' 'pista' 'pistas' 'sos' 'tutorial';

Extend only 'normal' replace
    *								-> LMode2
;

Verb	'descorre'
	* noun							-> OpenX
;

Verb	meta 'objetos' 'objs'
	*								-> RemarkableObjects
;
VerboIrregular "mostrar objetos clave" with imperativo 'objetos' 'objs';

Extend	'habla' replace
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	'conversa' 'platica'
	* noun							-> TalkTo
	* 'a'/'con' noun				-> TalkTo
	* creature						-> TalkTo
	* 'a'/'con' creature			-> TalkTo
	* 'por' noun					-> TalkOn
	* 'por' creature				-> TalkOn
;

Verb	meta 'temas' 't//'
	*								-> TopicInventory
;
VerboIrregular "mostrar inventario de temas" with imperativo 'temas' 't//';

Extend	'ponte' replace
	*								-> Wear
	* noun							-> Wear
	* 'con' noun					-> Wear
;

Extend	only 'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme' replace
	*								-> WearX
	* noun							-> WearX
	* 'con' noun					-> WearX
;
VerboIrregular "vestir" with imperativo 
	'vistete' 'vestirse' 'vestirte' 'vestirme' 'visteme';

!!------------------------------------------------------------------------------

#Ifdef TARGET_GLULX;
[ AudioSub;
	if (Damusix.HayAudio()) <<AudioOff>>;
	else <<AudioOn>>;
];

[ AudioOnSub;
	if (Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba activada.";
	Damusix.ActivarAudio();
	print_ret (parser) "Reproducción de audio activada.";
];

[ AudioOffSub;
	if (~~Damusix.HayAudio())
		print_ret (parser) "La reproducción de audio ya estaba desactivada.";
	Damusix.DesactivarAudio();
	print_ret (parser) "Reproducción de audio desactivada.";
];
#Endif; ! TARGET_GLULX;

[ CloseXSub;
	print (parser) "En lugar de ~correr~ el objeto, se intenta utilizar 
	la acción ~cerrar~, que en este contexto es sinónima, y es más general. 
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se 
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Close noun second>>;
];

!! Basada en la implementación de "verblibm.h":
[ DisrobeSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar qué quieres quitarte.";
	if (ObjectIsUntouchable(noun)) return;
	if (noun hasnt worn) return L__M(##Disrobe, 1, noun);
	give noun ~worn;
	if (AfterRoutines() == 1) rtrue;
	if (keep_silent == 1) rtrue;
	L__M(##Disrobe, 2, noun);
];

[ FireAtSub;
	if (second == revolver 
		|| (second == nothing && IndirectlyContains(player, revolver))) {
		if (revolver.out_of_ammo()) {
			if (GRAMMATICAL_INFLECTION == THIRD_PERSON_PRESENT)
				print_ret (The) revolver, " está", (n) revolver, " descargad", 
				(o) revolver, ". No puede disparar.";
			print_ret (The) revolver, " estaba", (n) revolver, " descargad",
			(o) revolver, ". No podía disparar.";
		}
		if (noun == nothing or revolver) {
			if (GRAMMATICAL_INFLECTION == THIRD_PERSON_PRESENT)
				"Frustrado, siente ganas de disparar sobre algo. Aunque 
				ponerse a disparar al aire probablemente no sea muy buena 
				idea.";
			"Frustrado, sentía ganas de disparar sobre algo. Aunque ponerse a 
			disparar al aire probablemente no hubiese sido muy buena idea.";
		}
		if (GRAMMATICAL_INFLECTION == THIRD_PERSON_PRESENT)
			"Frustrado, siente ganas de disparar sobre algo. Aunque pegar un 
			tiro ", (al) noun, " probablemente no sea muy buena idea.";
		"Frustrado, sentía ganas de disparar sobre algo. Aunque pegar un 
		tiro ", (al) noun, " probablemente no hubiese sido muy buena idea.";
	}
	if (GRAMMATICAL_INFLECTION == THIRD_PERSON_PRESENT)
		"Necesita un arma para hacer algo así.";
	"Necesitaba un arma para hacer algo así.";
];

[ HelpOnSub;
	if (HelpSystem.has_ended()) {
		return HelpSystem.print_default_clue();
	}
	if (HelpSystem has on) {
		HelpSystem.activate();
		return HelpSystem.each_turn(true);
	}
	if (HelpSystem.is_active()) {
		print_ret (parser) "El sistema de ayuda ya estaba activado.";
	}
	HelpSystem.activate();
	print_ret (parser) "Sistema de ayuda activado.";
];

[ HelpOffSub;
	if (~~HelpSystem.is_active())
		print_ret (parser) "El sistema de ayuda ya estaba desactivado.";
	HelpSystem.deactivate();
	print_ret (parser) "Sistema de ayuda desactivado.";
];

[ OpenXSub;
	print (parser) "En lugar de ~descorrer~ el objeto, se intenta utilizar 
	la acción ~abrir~, que en este contexto es sinónima, y es más general. 
	(Apenas hay objetos corredizos en el mundo del relato, pero muchos se 
	pueden abrir y cerrar.)";
	new_line; new_line;
	<<Open noun second>>;
];

[ RemarkableObjectsSub;
	remarkableObjectsCount = 0;
	LoopOverScope(CountRemarkableObjects);
	if (remarkableObjectsCount == 0)
		print_ret (parser) "No hay objetos destacables con los que puedas 
		interactuar.";
	start_parser_style();
	print "Puedes interactuar con";
	LoopOverScope(PrintRemarkableObjects);
	print ".";
	end_parser_style();
	new_line;
	return true;
];

[ TalkOnSub;
	start_parser_style();
	print "Habla con ", (name) noun;
	end_parser_style();
	new_line;
	<<TalkTo noun second>>;
];

[ TalkToSub;
	if ( noun == player ) {
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Hablar con uno mismo no resulta especialmente divertido.";
		4,5,6:	"Hablar con uno mismo no resultaba especialmente divertido.";
		}
	}
	if ( noun hasnt animate ) 
		switch (GRAMMATICAL_INFLECTION) {
		1,2,3:	"Mejor intentar hablar con cosas que puedan devolver 
				una respuesta.";
		4,5,6:	"Mejor intentar hablar con cosas que pudiesen devolver 
				una respuesta.";
	}
	switch (GRAMMATICAL_INFLECTION) {
	1:	print_ret (The) noun, " no parece", (n) noun, " estar interesad", 
		(o) noun, " en hablar conmigo.";
	2:	print_ret (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	3:	print (The) noun, " no parece", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	4:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar conmigo.";
	5:	print_ret (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar contigo.";
	6:	print (The) noun, " no parecía", (n) noun, " estar interesad",
		(o) noun, " en hablar con ";
		if (player has female || 
			(player provides gender && player.gender == G_FEMENINO))
			print "ella";
		else
			print "él";
		".";
	}
];

[ TopicInventorySub;
	if (ConversationManager.is_running()) {
		if (ConversationManager.topic_inventory_size() > 0) {
			ConversationManager.show_topic_inventory();
		} else {
			print_ret (parser) "No hay temas disponibles en este momento.";
		}
	} else {
		print_ret (parser) "No hay conversaciones activas en este momento.";
	}
];

!! Basada en la implementación de "verblibm.h":
[ WearSub;
	if (noun == nothing)
		print_ret (parser) "Tienes que indicar con qué quieres vestirte.";
	if (ObjectIsUntouchable(noun)) return;
	if (noun hasnt clothing)    return L__M(##Wear, 1, noun);
	if (parent(noun) ~= player)
		if (AttemptToTakeObject(noun))
			return true;
	if (noun has worn)          return L__M(##Wear, 3, noun);
	give noun worn;
	if (AfterRoutines() == 1) rtrue;
	if (keep_silent == 1) rtrue;
	L__M(##Wear, 4, noun);
];

[ WearXSub;
	<<Wear noun>>;
];

!!------------------------------------------------------------------------------

#Ifdef	DEBUG;
Verb meta 'gna'
	* multi							-> GNA
;

[ GNA g;
	g = GetGNAOfObject(noun);
	print g, ": ";
	switch (g) {
		0,1,2,3,4,5: print "animado ";
		default:	 print "inanimado ";
	}
	switch (g) {
		0,1,2,6,7,8: print "singular ";
		default:	 print "plural ";
	}
	switch (g) {
		0,3,6,9:	 print "masculino";
		1,4,7,10:	 print "femenino";
		default:	 print "neutro";
	}
];

[ GNASub;
	start_parser_style();
	print "Objeto: ";
	roman_style();
	print (name) noun; 
	parser_style();
	print ". (", (The) noun," / ", (the) noun," / ", (a) noun, 
	" / -", (o) noun, ")^GNA ", (GNA) noun;
	end_parser_style();
	new_line;
];
#Endif; ! DEBUG;


!!==============================================================================
!!	Definición de atributos, clases y objetos
!!------------------------------------------------------------------------------

Include ">1973_escena0.inf";	! Prólogo: Clases y objetos especiales
Include ">1973_escena1.inf";	! Escena 1: Habitación de Gabriel
Include ">1973_escena2.inf";	! Escena 2: Café Blanca Florida
Include ">1973_escena3.inf";	! Escena 3: Calles de Santiago
Include ">1973_escena4.inf";	! Escena 4: Flores para un joven difunto


