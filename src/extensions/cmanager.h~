

!!==============================================================================
!!
!!	CONVERSATION MANAGER
!!	Sistema de conversación por etiquetas
!!
!!==============================================================================
!!
!!	File:			cmanager.h
!!	Author(s):		Mastodon - librería original 'NPC_Conversacion'
!!					J. Francisco Martín (jfm.lisaso@gmail.com)
!!	Language:		ES (Castellano)
!!	System:			Inform, INFSP 6
!!	Platform:		Máquina-Z / Glulx
!!	Version:		1.0
!!	Released:		2012/01/04
!!
!!------------------------------------------------------------------------------
!!
!!	Copyright (c) 2009, Mastodon
!!	Copyright (c) 2012, J. Francisco Martín
!!
!!	Este programa es software libre: usted puede redistribuirlo y/o 
!!	modificarlo bajo los términos de la Licencia Pública General GNU 
!!	publicada por la Fundación para el Software Libre, ya sea la versión 
!!	3 de la Licencia, o (a su elección) cualquier versión posterior.
!!
!!	Este programa se distribuye con la esperanza de que sea útil, pero 
!!	SIN GARANTÍA ALGUNA; ni siquiera la garantía implícita MERCANTIL o 
!!	de APTITUD PARA UN PROPÓSITO DETERMINADO. Consulte los detalles de 
!!	la Licencia Pública General GNU para más información.
!!
!!	Debería haber recibido una copia de la Licencia Pública General GNU 
!!	junto a este programa. En caso contrario, consulte
!!	<http://www.gnu.org/licenses/>.
!!
!!------------------------------------------------------------------------------
!!
!!	Esta librería es una remodelación de la versión 1.0 (2010/04/19) de la 
!!	librería 'NPC_Conversacion' escrita por Mastodon que tan sólo realiza 
!!	pequeñas modificaciones a la original, como alterar ciertos comportamientos 
!!	y cambiar el nombre de algunas funcopnes y objetos. A continuación se 
!!	transcribe la descripción original de la librería:
!!
!!	Librería genérica para tratamiento de conversaciones al estilo de Eric Eve 
!!	(ver Shelter from the Storm). El resultado es igual a la clásica por menús 
!!	de LucasArts, pero la forma de presentarla y de introducir las opciones es 
!!	diferente y más "natural". Transcripción de ejemplo:
!!
!!		> hablar con pirata
!!		Inicias una interesante conversación con el pirata patapalo. 
!!		"Buenas, grumete, ¿qué te trae por aquí?"
!!		(Se te ocurre hablarle de la busqueda del tesoro, preguntarle por la 
!!		isla secreta, o cambiar de tema)
!!		> hablar del tesoro
!!		"Verás, pirata", le dices, "hace tiempo que estoy buscando el famoso 
!!		tesoro, ¿sabes algo de el?"
!!		"Mi querido marinero de agua dulce", te responde con sorna, "a ti te lo 
!!		voy a decir... salvo... quizás puedas hacerme un favor y entonces me 
!!		pensaría ayudarte".
!!		(Consideras aceptar el trato, preguntarle por la isla secreta, o 
!!		cambiar de tema)
!!		> cambio de tema
!!		"Pues parece que va a llover por aquí", cortas, mirando al cielo.
!!		"Ahh, veo que eres un chico listo, creo que vamos a hacer buenas migas."
!!		... etc ...
!!
!!	El reconocimiento de patrones se hace mediante parseado ligero y 
!!	comparación entre la entrada del jugador y la definición de cada tema, de 
!!	forma que la librería sabe interpretar (casi siempre) la intención del 
!!	jugador por una serie de palabras clave indicadas en los temas. Se ponen 
!!	directamente en el prompt sin necesidad de definir nuevas gramáticas.
!!
!!	USO 
!!
!!	Para usar la librería únicamente hay que incluir la siguiente línea en la 
!!	rutina BeforeParsing (crearla si no existe):
!!
!!		ConversationManager.try();
!!
!!------------------------------------------------------------------------------
System_file;

!! Descomentar para obtener información de depuración:
!Constant DEBUG_CONVERSATION;
!! Array para guardar palabras temporalmente:
Array	tmp_text1 -> 64;

!!------------------------------------------------------------------------------
!! Funciones de depuración:
#Ifdef	DEBUG_CONVERSATION;
! Función para pintar un String Array
[ PrintStringArray the_array i;
	print "(", the_array-->0, ")";
	for (i=WORDSIZE : i<(the_array-->0)+WORDSIZE : i++) {
		print (char)the_array->i;
	}
];
! Funcion para pintar una palabra del Prompt de entrada del jugador
[ PrintPromptWord num_word dir i;
	dir = WordAddress(num_word);
	for (i = 0 : i < WordLength(num_word) : i++) {
		print (char)dir->i;
	}
];
#Endif;	! DEBUG_CONVERSATION

!!------------------------------------------------------------------------------
!! Compara una entrada en array (del prompt, indicada por el número de orden de 
!! la palabra) con una palabra de diccionario.
!! Devuelve 1 si coinciden; 0 si son diferentes
[compareWord num_word_prompt dictword i len;
	!! A) Volcamos la palabra de diccionario a un array
	#Ifdef	TARGET_ZCODE;
	@output_stream 3 tmp_text1;
	print (address)dictword; ! vuelca la palabra de diccionario en el array
	@output_stream -3;
	#Ifnot;	! TARGET_GLULX;
	tmp_text1->(WORDSIZE-1) = PrintAnyToArray(tmp_text1+WORDSIZE, 60, dictword);
	#Endif;	! TARGET_
	len = tmp_text1->(WORDSIZE-1);

	!! B) Si el último carácter es una coma, se elimina para evitar conflictos 
	!! con la conversión de infinitivos y los diccionarios en informATE --> NO 
	!! DEBE HABER NUNCA PALABRAS EN INFINITIVO EN EL DICCIONARIO. (No vale para 
	!! palabras que antes de ponerles la coma tengan 9 o más caracteres debido 
	!! a una limitación de Inform.)
	if (tmp_text1->(len+WORDSIZE-1) == ',') {
		tmp_text1->(len+WORDSIZE-1) = 0; ! Eliminamos ',' del buffer
		(tmp_text1->(WORDSIZE-1))--; ! Reducimos el tamaño indicado en el buffer
		len = tmp_text1->(WORDSIZE-1); ! Y actualizamos la long. al nuevo valor
	}
	
	#Ifdef	DEBUG_CONVERSATION;
	print "Comparando prompt: <", (PrintPromptWord)num_word_prompt,
	"> con palabra de diccionario:<", (PrintStringArray)tmp_text1, ">^";
	#Endif;

	!! Si tienen diferentes longitudes devuelve NO coincidente, tratando el 
	!! especial de la limitación a 9 caracteres de las palabras de diccionario 
	!! en Inform.
	if (WordLength(num_word_prompt) ~= len &&
	    ~~(WordLength(num_word_prompt) >9 && len == 9))
		return 0;
		
	!! Para la misma longitud, miramos letra a letra buscando diferencias
	for (i = 0: i < len: i++) {
		if (WordAddress(num_word_prompt)->i ~= tmp_text1->(i+WORDSIZE))
			return 0; ! Letra diferente, se retorna que son diferentes
	}
	
	!! Son iguales
	return 1;
];

!!------------------------------------------------------------------------------
Class CM_Conversation
 with	start [ i;
			!! Agrega todos los topics que van a formar parte de la conversación
			self.end(); ! Empieza borrando todo, por si acaso
			for (i = 0 : i < self.#topics/WORDSIZE : i++) {
				!print "Move:", (string)(self.&topics-->i).desc_corta, "^";
				move self.&topics-->i to self;
			}
		],
		end [ o;
			!! Borra todos los topics activos actualmente en la conversación
			objectloop (o in self) remove o;
			self.finished = true;
		],
		show_topic_list [ o;
			for (o = child(self) : o ~= nothing : o = sibling(o)) {
				PrintOrRun(o,desc_corta, true);
				if (sibling(o) ~= nothing)  {
					if (sibling(sibling(o)) == nothing)
						print " o ";
					else
						print ", ";
				}
			}
		],
		new_topic [ topic; 
			move topic to self;
		],
		add_subtopics [ topic i;
			for (i = 0 : i < topic.#topics/WORDSIZE : i++) {
				move topic.&topics-->i to self;
			}
		],
		remove_topic [ topic;
			remove topic;
		],
		finished false,
;

!!------------------------------------------------------------------------------
Class	CM_Topic
 with	compare_prompt [ i j;
			self.hits = 0;
			for (i = 0 : i < self.#desc_words/WORDSIZE : i++) {
				for (j = 1 : j <= num_words : j++) {
					if (compareWord(j, self.&desc_words-->i)) 
						self.hits++;
				}
			}
		],
		!! Num. palabras de este tema que coinciden con la entrada del jugador
		hits 0,
		!! (opcional) Acción a ejecutar tras haber leído este tema
		accion [; ],
;

!!------------------------------------------------------------------------------
Object	ConversationManager
 with	no_topics [;
			print_ret (parser_type) "No hay temas que comentar.";
		],
!!		no_topics  "(No se te ocurre qué más comentar)",
		start [ conversacion;
			if ( conversacion.finished ) {
				PrintOrRun(self, no_topics);
				return true;
			}
			self.select(conversacion);
			self.current_conversation.start();
			PrintOrRun(self.current_conversation, inicio);
			print "^";
			self.ask();
		],
		end_conversation [;
			PrintOrRun(self.current_conversation, fin);
			self.current_conversation = 0;
		],
		select [ conversacion;
			self.current_conversation = conversacion;
		],
		try [ o o_tmp_hits;
			if (self.current_conversation) {
				!! A) Da un repaso a los temas actuales intentando hacerlos 
				!! encajar con el prompt
				self.hits = 0; self.topic = 0;
				objectloop (o in self.current_conversation) {
					#Ifdef DEBUG_CONVERSATION;
					print "Probando: ", (string)o.desc_corta, "... ";
					#Endif;
					
					!! Calculamos el número de coincidencias del tema en 
					!! relación al total de palabras (%)
					o.compare_prompt();
					!o_tmp_hits = (o.hits*100)/(o.#desc_words*WORDSIZE); 
					o_tmp_hits = (o.hits*100)/num_words; 
					
					#ifdef DEBUG_CONVERSATION;
					print "Ajuste de ", o.hits, " sobre ", 
					o.#desc_words/WORDSIZE, " palabras: ", o_tmp_hits, "%^";
					#endif;
					
					!! Si hay una coincidencia mayor al máximo actual:
					if (o_tmp_hits > self.hits) {
						self.hits = o_tmp_hits;
						self.topic = o;
					}
				} ! objectloop

				!! B) Mostrar la respuesta al tema elegido, si lo hay, y añadir 
				!! los subtopics
				if (self.hits) {
					#ifdef DEBUG_CONVERSATION;
					print "Tema seleccionado: ", 
					(string)self.topic.desc_corta, "^";
					#endif;
					PrintOrRun(self.topic, desc_larga);
					print "^";
					PrintOrRun(self.topic, desc_respuesta);
					print "^";
					PrintOrRun(self.topic, accion);
					
					!! Sustituimos la accion tecleada por una fake que no 
					!! diga nada
					parse-->1 = 'npc_talk,';
					num_words = 1;
					!! Por último añadimos los nuevos topics, si los hay, y 
					!! repreguntamos
					self.current_conversation.remove_topic(self.topic);
					self.current_conversation.add_subtopics(self.topic);
					!! Ahora la acción NPC_OK_Talk toma el control para mostrar 
					!! la nueva lista de topics
				}
			}

			!! Retorna de la función sin hacer nada ->
			!! tratamiento normal del prompt
			return false;
		],
		!! Hits del tema con más coincidencias (en tanto por 100 sobre el 
		!! número de palabras del tema)
		hits 0,
		!! Tema con más porcentaje de coincidencia hasta el momento
		topic 0,
		current_conversation 0,
!!		preguntas 
!!			"Se te ocurre" "Piensas en" "Podrías" "Sería posible" 
!!			"No sería mala idea",
!!		ask [n;
!!			n = random(self.#preguntas/WORDSIZE)-1;
!!			print "(", (string)self.&preguntas-->n, " ";
!!			self.current_conversation.show_topic_list();
!!			")";
		ask [;
			parser_style_open_brackets();
			print "Temas: ";
			self.current_conversation.show_topic_list();
			print ".";
			parser_style_close_brackets();
			new_line;
			return true;
		],
;

!!------------------------------------------------------------------------------
!! Gramática de pega que se activa cuando se proporciona una de las opciones 
!! válidas (muestra la lista de topics pendientes)
Verb 'npc_talk,'
  *                                   -> NPC_Talk_OK
  * topic							  -> NPC_Talk_OK;


[ NPC_Talk_OKSub;
	! Tras responder a una pregunta, vuelve a mostrar la lista de temas
	if (child(ConversationManager.current_conversation) ~= nothing)
		ConversationManager.ask();
	else
		ConversationManager.end_conversation();
	return true;
];


